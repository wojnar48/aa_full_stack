# README

Slack-inspired, single-page chat app with a RESTful Ruby on Rails API and PostgreSQL backend that serves JSON data to a React / Redux front-end.

![lax image][lax_channels]

[Lax Live][live]

### Technologies & Gems
- `Ruby on Rails` - back-end API
- `PostgreSQL` - database
- `React` - front-end rendering
- `Redux` - front-end state management
- `jQuery` - AJAX requests and DOM manipulation
- `Pusher` - real-time chat and notifications
- `AWS S3` - cloud storage for user avatars
- `jbuilder gem` - data curation on back-end
- `figaro gem` - secure handling of API keys
- `paperclip gem` - used with ActiveRecord to allow models to store files easily
- `bcrypt gem` - used for custom authentication logic

## Features & Implementation

### Authentication

Lax has custom authentication logic developed from scratch using the BCrypt gem and hashing algorithm. User passwords are digested and stored in
the database as hashes that are used by the SessionsController to manage login/logout logic. On successful login, each user is assigned a url-safe session
token generated by the SecureRandom gem which is then stored in the current user's cookies to allow for current session management.

### Live Features

Live chat features are implemented using the Pusher API which allows for real-time, bidirectional communication via WebSockets. User actions on the front-end fire
AJAX requests that in turn trigger events on the back-end that are braodcast to all subscribers who are bound to those events. This gives users the ability to
experience updates without the need to refresh the page. The snippet below subscribes and binds the client to the `new-message` event as soon as the component is
mounted, while the conditional statement ensures that only the current active channel sees the new message. Without the if statement it would appear that all of
the channels received the a new message until a page refresh is executed.

```js
componentDidMount () {
  const messages = this.pusher.subscribe('messages');
  messages.bind('new-message', (data) => {
    const message = data.message;
    if (message.chatroomId === this.props.activeChannel.id) {
      this.props.receiveMessage(message);
    }
  });
}
```

### Optimized Data Handling

To ensure good responsiveness, selective AJAX requests are used to fetch only the data for the current active channel and processing, where necessary, is done
mostly in the back-end to leverage the server's resources. In addition, eager loading through associations is used to avoid N+1 queries and to decrease the overhead
associated with connecting to the database multiple times. In the case of messages, which are a frequently fetched resource as users browse channels, the
`includes` method is used to eagerly fetch each message's `user` association so that the database is not hit multiple times when the data is required in the
jbuilder view.

```ruby
def index
  @messages = @chatroom.messages.includes(:user)
  render 'api/messages/index'
end
```

Note: Implementing the above optimization decreased the ActiveRecord portion of fetching the largest channel by a factor of 10 on the production environment.

### AWS S3 Storage

Amazons S3 provides cloud storage for user uploaded avatar files and ensures that as the user base grows, the application and its storage needs will
be able to scale efficiently.

## Future Direction

* [X] Message Search
* [X] Live Notifications
* [X] Message Formatting
* [X] GIF Support
* [X] Emoticon Support

[live]: http://laxapp.online
[lax_channels]: docs/images/lax_channels.gif
